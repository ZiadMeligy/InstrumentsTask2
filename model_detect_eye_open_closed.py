# -*- coding: utf-8 -*-
"""Model_detect_eye_open_closed

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P4wCF3ubA6whhH_1p47RIJRTdbY5oy7Z
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
uploaded = files.upload()

from scipy.io import arff

# Assuming the file was uploaded as 'EEG Eye State.arff'


import pandas as pd

# Create a DataFrame (assuming you already have this step)
data = pd.read_csv('EEG_Eye_State')

def remove_outliers_iqr(data, column, eye_detection_column):
    # Ensure the columns are numeric
    data[column] = pd.to_numeric(data[column], errors='coerce')
    eye_detection_column = pd.to_numeric(eye_detection_column, errors='coerce')

    # Calculate the first quartile and the third quartile
    q1 = data[column].quantile(0.25)
    q3 = data[column].quantile(0.75)
    # Calculate the IQR
    iqr = q3 - q1
    # Calculating the threshold
    threshold = 3 * iqr
    # Defining the lower and upper bounds
    lower_bound = q1 - threshold
    upper_bound = q3 + threshold
    # Filtering and returning the filtered data and eyeDetection column
    filtered_data = data[(data[column] >= lower_bound) &
                         (data[column] <= upper_bound)]
    filtered_eye_detection = eye_detection_column[(data[column] >= lower_bound) &
                                                  (data[column] <= upper_bound)]
    return filtered_data, filtered_eye_detection

# Specify the name of your "eyeDetection" column
eye_detection_column = data["eyeDetection"]

# Let's apply our modified method and save the new filtered data and eyeDetection column
for q in data.columns:
    data, eye_detection_column = remove_outliers_iqr(data, q, eye_detection_column)

# Taking a look at our filtered data
print(data)

# Taking a look at the filtered "eyeDetection" column
print(eye_detection_column)

import numpy as np

# Select all columns except 'eyeDetection'
eeg_data = data.loc[:, data.columns != 'eyeDetection']

# Count the number of rows in the selected data
count = eeg_data.shape[0]

# Calculate the time interval
time_interval = round(117 / count, 5)

# Create the x_axis using linspace
x_axis = np.linspace(0, 117, count)

from scipy.signal import butter, lfilter

# Assuming you have a DataFrame named 'data'
count = data.count(axis=0).values[0]
total_interval = 117

sample_period = total_interval / count

f_sample = 1 / sample_period

# Define a bandpass filter
def bandpass_filter(data, lowcut, highcut, fs, order=5):
    nyquist = 0.5 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band')
    y = lfilter(b, a, data)
    return y

# Create a list of columns to filter, excluding 'eyeDetection'
columns_to_filter = [col for col in data.columns if col != 'eyeDetection']

# Apply bandpass filter to all selected columns
for column in columns_to_filter:
    data[column + '_filtered'] = bandpass_filter(data[column], 3, 20, f_sample, 3)

# Now, you have filtered columns for all data except 'eyeDetection'.

df = pd.DataFrame(data)
from sklearn.preprocessing import StandardScaler

# Assuming that your DataFrame contains the "eyeDetection" column, you can continue with the following steps:

# Separate features (X) and target (y)
X = df.drop("eyeDetection", axis=1)  # Features
y = df['eyeDetection']  # Target variable

# Standardize the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

from sklearn.preprocessing import LabelEncoder

# Encode the labels
label_encoder = LabelEncoder()
y_train_encoded = label_encoder.fit_transform(y_train)

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.preprocessing import LabelEncoder

# Encode the labels
label_encoder = LabelEncoder()
y_train_encoded = label_encoder.fit_transform(y_train)


# Create and train a Random Forest classifier
model = RandomForestClassifier()
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model's performance
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print(f"Model Accuracy: {accuracy * 100:0.2f}%")
print(report)